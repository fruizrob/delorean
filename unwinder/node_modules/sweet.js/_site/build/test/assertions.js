"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testEval = exports.testParse = exports.stmt = exports.expr = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.testParseFailure = testParseFailure;
exports.testModule = testModule;
exports.testThrow = testThrow;

var _sweet = require("../src/sweet");

var _expect = require("expect.js");

var _expect2 = _interopRequireDefault(_expect);

var _ramda = require("ramda");

var _babelCore = require("babel-core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function expr(program) {
  return stmt(program).expression;
}

function stmt(program) {
  return program.items[0];
}

function testParseFailure() {
  // TODO
}

function testParseWithOpts(code, acc, expectedAst, options) {
  var parsedAst = (0, _sweet.parse)(code, options);
  var isString = function isString(x) {
    return (0, _ramda.type)(x) === 'String';
  };
  var isObject = function isObject(x) {
    return (0, _ramda.type)(x) === 'Object';
  };
  var isArray = function isArray(x) {
    return (0, _ramda.type)(x) === 'Array';
  };

  function checkObjects(expected, actual) {
    var checkWithHygiene = (0, _ramda.cond)([[(0, _ramda.and)(isString, (0, _ramda.equals)('<<hygiene>>')), (0, _ramda.curry)(function (a, b) {
      return true;
    })], [isObject, (0, _ramda.curry)(function (a, b) {
      return checkObjects(a, b);
    })], [isArray, (0, _ramda.curry)(function (a, b) {
      return (0, _ramda.map)(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var a = _ref2[0];
        var b = _ref2[1];
        return checkObjects(a, b);
      }, (0, _ramda.zip)(a, b));
    })], [_ramda.T, (0, _ramda.curry)(function (a, b) {
      return (0, _expect2.default)(b).to.be(a);
    })]]);

    (0, _ramda.mapObjIndexed)(function (prop, key, ob) {
      var checker = checkWithHygiene(prop);
      (0, _expect2.default)(actual).to.have.property(key);
      checker(actual[key]);
    }, expected);
  }
  checkObjects(expectedAst, acc(parsedAst));
}

function testModule(code, loader, expectedAst) {
  return testParseWithOpts(code, function (x) {
    return x;
  }, expectedAst, {
    loc: false,
    moduleResolver: function moduleResolver(x) {
      return x;
    },
    moduleLoader: function moduleLoader(path) {
      return loader[path];
    }
  });
}

// if a property has the string <<hygiene> it is ignored
function testParse(code, acc, expectedAst) {
  return testParseWithOpts(code, acc, expectedAst, {
    loc: false,
    moduleResolver: function moduleResolver() {
      return "";
    },
    moduleLoader: function moduleLoader() {
      return "";
    }
  });
}

function testEval(source, expectedOutput) {
  var result = (0, _sweet.compile)(source, { cwd: '.', transform: _babelCore.transform });
  var output;
  eval(result.code);
  (0, _expect2.default)(output).to.be(expectedOutput);
}

function testThrow(source) {
  (0, _expect2.default)(function () {
    return (0, _sweet.compile)(source, { cwd: '.', transform: _babelCore.transform });
  }).to.throwError();
}

exports.expr = expr;
exports.stmt = stmt;
exports.testParse = testParse;
exports.testEval = testEval;
//# sourceMappingURL=data:application/json;base64,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QUFOO0FBQ2hCLGtCQUFjO2FBQU07S0FBTjtHQUhULENBQVAsQ0FEeUM7Q0FBM0M7O0FBUUEsU0FBUyxRQUFULENBQWtCLE1BQWxCLEVBQTBCLGNBQTFCLEVBQTBDO0FBQ3hDLE1BQUksU0FBUyxvQkFBUSxNQUFSLEVBQWdCLEVBQUUsS0FBSyxHQUFMLEVBQVUsK0JBQVosRUFBaEIsQ0FBVCxDQURvQztBQUV4QyxNQUFJLE1BQUosQ0FGd0M7QUFHeEMsT0FBSyxPQUFPLElBQVAsQ0FBTCxDQUh3QztBQUl4Qyx3QkFBTyxNQUFQLEVBQWUsRUFBZixDQUFrQixFQUFsQixDQUFxQixjQUFyQixFQUp3QztDQUExQzs7QUFPTyxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkI7QUFDaEMsd0JBQU87V0FBTSxvQkFBUSxNQUFSLEVBQWdCLEVBQUUsS0FBSyxHQUFMLEVBQVUsK0JBQVosRUFBaEI7R0FBTixDQUFQLENBQXNELEVBQXRELENBQXlELFVBQXpELEdBRGdDO0NBQTNCOztRQUtMO1FBQU07UUFBTTtRQUFXIiwiZmlsZSI6ImFzc2VydGlvbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgY29tcGlsZSB9IGZyb20gXCIuLi9zcmMvc3dlZXRcIjtcbmltcG9ydCBleHBlY3QgZnJvbSBcImV4cGVjdC5qc1wiO1xuaW1wb3J0IHsgemlwLCBjdXJyeSwgZXF1YWxzLCBjb25kLCBpZGVudGl0eSwgVCwgYW5kLCBjb21wb3NlLCB0eXBlLCBtYXBPYmpJbmRleGVkLCBtYXAsIGtleXMsIGhhcyB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJ2JhYmVsLWNvcmUnO1xuXG5mdW5jdGlvbiBleHByKHByb2dyYW0pIHtcbiAgcmV0dXJuIHN0bXQocHJvZ3JhbSkuZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gc3RtdChwcm9ncmFtKSB7XG4gIHJldHVybiBwcm9ncmFtLml0ZW1zWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFBhcnNlRmFpbHVyZSgpIHtcbiAgLy8gVE9ET1xufVxuXG5mdW5jdGlvbiB0ZXN0UGFyc2VXaXRoT3B0cyhjb2RlLCBhY2MsIGV4cGVjdGVkQXN0LCBvcHRpb25zKSB7XG4gIGxldCBwYXJzZWRBc3QgPSBwYXJzZShjb2RlLCBvcHRpb25zKTtcbiAgbGV0IGlzU3RyaW5nID0gKHgpID0+IHR5cGUoeCkgPT09ICdTdHJpbmcnO1xuICBsZXQgaXNPYmplY3QgPSAoeCkgPT4gdHlwZSh4KSA9PT0gJ09iamVjdCc7XG4gIGxldCBpc0FycmF5ID0gKHgpID0+IHR5cGUoeCkgPT09ICdBcnJheSc7XG5cbiAgZnVuY3Rpb24gY2hlY2tPYmplY3RzKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICBsZXQgY2hlY2tXaXRoSHlnaWVuZSA9IGNvbmQoW1xuICAgICAgW2FuZChpc1N0cmluZywgZXF1YWxzKCc8PGh5Z2llbmU+PicpKSwgY3VycnkoKGEsIGIpID0+IHRydWUpXSxcbiAgICAgIFtpc09iamVjdCwgY3VycnkoKGEsIGIpID0+IGNoZWNrT2JqZWN0cyhhLCBiKSldLFxuICAgICAgW2lzQXJyYXksIGN1cnJ5KChhLCBiKSA9PiBtYXAoKFthLCBiXSkgPT4gY2hlY2tPYmplY3RzKGEsIGIpLCB6aXAoYSwgYikpKV0sXG4gICAgICBbVCwgY3VycnkoKGEsIGIpID0+IGV4cGVjdChiKS50by5iZShhKSldXG4gICAgXSk7XG5cbiAgICBtYXBPYmpJbmRleGVkKChwcm9wLCBrZXksIG9iKSA9PiB7XG4gICAgICBsZXQgY2hlY2tlciA9IGNoZWNrV2l0aEh5Z2llbmUocHJvcCk7XG4gICAgICBleHBlY3QoYWN0dWFsKS50by5oYXZlLnByb3BlcnR5KGtleSk7XG4gICAgICBjaGVja2VyKGFjdHVhbFtrZXldKTtcbiAgICB9LCBleHBlY3RlZCk7XG4gIH1cbiAgY2hlY2tPYmplY3RzKGV4cGVjdGVkQXN0LCBhY2MocGFyc2VkQXN0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0TW9kdWxlKGNvZGUsIGxvYWRlciwgZXhwZWN0ZWRBc3QpIHtcbiAgcmV0dXJuIHRlc3RQYXJzZVdpdGhPcHRzKGNvZGUsIHggPT4geCwgZXhwZWN0ZWRBc3QsIHtcbiAgICBsb2M6IGZhbHNlLFxuICAgIG1vZHVsZVJlc29sdmVyOiB4ID0+IHgsXG4gICAgbW9kdWxlTG9hZGVyOiBwYXRoID0+IGxvYWRlcltwYXRoXVxuICB9KTtcbn1cblxuLy8gaWYgYSBwcm9wZXJ0eSBoYXMgdGhlIHN0cmluZyA8PGh5Z2llbmU+IGl0IGlzIGlnbm9yZWRcbmZ1bmN0aW9uIHRlc3RQYXJzZShjb2RlLCBhY2MsIGV4cGVjdGVkQXN0KSB7XG4gIHJldHVybiB0ZXN0UGFyc2VXaXRoT3B0cyhjb2RlLCBhY2MsIGV4cGVjdGVkQXN0LCB7XG4gICAgbG9jOiBmYWxzZSxcbiAgICBtb2R1bGVSZXNvbHZlcjogKCkgPT4gXCJcIixcbiAgICBtb2R1bGVMb2FkZXI6ICgpID0+IFwiXCIsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0ZXN0RXZhbChzb3VyY2UsIGV4cGVjdGVkT3V0cHV0KSB7XG4gIGxldCByZXN1bHQgPSBjb21waWxlKHNvdXJjZSwgeyBjd2Q6ICcuJywgdHJhbnNmb3JtIH0pO1xuICB2YXIgb3V0cHV0O1xuICBldmFsKHJlc3VsdC5jb2RlKTtcbiAgZXhwZWN0KG91dHB1dCkudG8uYmUoZXhwZWN0ZWRPdXRwdXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRocm93KHNvdXJjZSkge1xuICBleHBlY3QoKCkgPT4gY29tcGlsZShzb3VyY2UsIHsgY3dkOiAnLicsIHRyYW5zZm9ybX0pKS50by50aHJvd0Vycm9yKCk7XG59XG5cbmV4cG9ydCB7XG4gIGV4cHIsIHN0bXQsIHRlc3RQYXJzZSwgdGVzdEV2YWxcbn07XG4iXX0=
