import transit from "transit-js";
import {List} from "immutable";
import Syntax from "./syntax";
import {Symbol, gensym, SymbolClass} from "./symbol";
import {TokenClass, TokenType} from "shift-parser/dist/tokenizer";
let typeMap_466 = [TokenType.STRING, TokenType.EOS, TokenType.LPAREN, TokenType.RPAREN, TokenType.LBRACK, TokenType.RBRACK, TokenType.LBRACE, TokenType.RBRACE, TokenType.COLON, TokenType.SEMICOLON, TokenType.PERIOD, TokenType.ELLIPSIS, TokenType.ARROW, TokenType.CONDITIONAL, TokenType.INC, TokenType.DEC, TokenType.ASSIGN, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR, TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_SHL, TokenType.ASSIGN_SHR, TokenType.ASSIGN_SHR_UNSIGNED, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB, TokenType.ASSIGN_MUL, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD, TokenType.COMMA, TokenType.OR, TokenType.AND, TokenType.BIT_OR, TokenType.BIT_XOR, TokenType.BIT_AND, TokenType.SHL, TokenType.SHR, TokenType.SHR_UNSIGNED, TokenType.ADD, TokenType.SUB, TokenType.MUL, TokenType.DIV, TokenType.MOD, TokenType.EQ, TokenType.NE, TokenType.EQ_STRICT, TokenType.NE_STRICT, TokenType.LT, TokenType.GT, TokenType.LTE, TokenType.GTE, TokenType.INSTANCEOF, TokenType.IN, TokenType.NOT, TokenType.BIT_NOT, TokenType.AWAIT, TokenType.DELETE, TokenType.TYPEOF, TokenType.VOID, TokenType.BREAK, TokenType.CASE, TokenType.CATCH, TokenType.CLASS, TokenType.CONTINUE, TokenType.DEBUGGER, TokenType.DEFAULT, TokenType.DO, TokenType.ELSE, TokenType.EXPORT, TokenType.EXTENDS, TokenType.FINALLY, TokenType.FOR, TokenType.FUNCTION, TokenType.IF, TokenType.IMPORT, TokenType.LET, TokenType.NEW, TokenType.RETURN, TokenType.SUPER, TokenType.SWITCH, TokenType.THIS, TokenType.THROW, TokenType.TRY, TokenType.VAR, TokenType.WHILE, TokenType.WITH, TokenType.NULL, TokenType.TRUE, TokenType.FALSE, TokenType.YIELD, TokenType.NUMBER, TokenType.STRING, TokenType.REGEXP, TokenType.IDENTIFIER, TokenType.CONST, TokenType.TEMPLATE, TokenType.ILLEGAL];
let ListHandler_467 = transit.makeWriteHandler({tag: () => "array", rep: v_472 => v_472});
let SyntaxHandler_468 = transit.makeWriteHandler({tag: () => "stx", rep: v_473 => {
  if (List.isList(v_473.token)) {
    return [v_473.token, v_473.context.scopeset];
  } else {
    let t = transit.objectToMap(v_473.token);
    t.set("type", typeMap_466.indexOf(v_473.token.type));
    return [t, v_473.context.scopeset];
  }
}});
let SymbolHandler_469 = transit.makeWriteHandler({tag: () => "symb", rep: v_474 => [v_474.name]});
let writer_470 = transit.writer("json", {handlers: transit.map([List, ListHandler_467, Syntax, SyntaxHandler_468, SymbolClass, SymbolHandler_469])});
function makeReader_471(bindings_475) {
  return transit.reader("json", {arrayBuilder: {init: node_476 => List().asMutable(), add: (ret_477, val_478, node_479) => ret_477.push(val_478), finalize: (ret_480, node_481) => ret_480.asImmutable(), fromArray: (arr_482, node_483) => List(arr_482)}, handlers: {stx: rep_484 => {
    if (List.isList(rep_484[0])) {
      let token = rep_484[0];
      return new Syntax(token, {bindings: bindings_475, scopeset: rep_484[1]});
    } else {
      let token = transit.mapToObject(rep_484[0]);
      token.type = typeMap_466[rep_484[0].get("type")];
      token.slice = rep_484[0].has("slice") ? transit.mapToObject(rep_484[0].get("slice")) : undefined;
      return new Syntax(token, {bindings: bindings_475, scopeset: rep_484[1]});
    }
  }, symb: rep_485 => {
    return Symbol(rep_485[0]);
  }}});
}
export {makeReader_471 as makeDeserializer, writer_470 as serializer};
