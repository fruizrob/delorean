import  * as _ from "ramda";
import TermExpander from "./term-expander";
import {List} from "immutable";
import ParseReducer from "./parse-reducer.js";
import reducer, {MonoidalReducer} from "shift-reducer";
import {makeDeserializer} from "./serializer";
import Syntax from "./syntax";
import codegen, {FormattedCodeGen} from "shift-codegen";
import {VarBindingTransform, CompiletimeTransform} from "./transforms";
import Term, {isEOF, isBindingIdentifier, isFunctionDeclaration, isFunctionExpression, isFunctionTerm, isFunctionWithName, isSyntaxDeclaration, isVariableDeclaration, isVariableDeclarationStatement, isImport, isExport} from "./terms";
import Reader from "./shift-reader";
import {unwrap} from "./macro-context";
import {replaceTemplate} from "./template-processor";
let geval_307 = eval;
export function sanitizeReplacementValues(values_310) {
  if (Array.isArray(values_310)) {
    return sanitizeReplacementValues(List(values_310));
  } else if (List.isList(values_310)) {
    return values_310.map(sanitizeReplacementValues);
  } else if (values_310 == null) {
    throw new Error("replacement values for syntax template must not be null or undefined");
  } else if (typeof values_310.next === "function") {
    return sanitizeReplacementValues(List(values_310));
  }
  return unwrap(values_310);
}
function loadForCompiletime_308(expr_311, context_312) {
  let deserializer_313 = makeDeserializer(context_312.bindings);
  let sandbox_314 = {syntaxQuote: function (strings_321, ...values_320) {
    let ctx_322 = deserializer_313.read(_.last(values_320));
    let reader_323 = new Reader(strings_321, ctx_322.context, _.take(values_320.length - 1, values_320));
    return reader_323.read();
  }, syntaxTemplate: function (str_325, ...values_324) {
    return replaceTemplate(deserializer_313.read(str_325), sanitizeReplacementValues(values_324));
  }};
  let sandboxKeys_315 = List(Object.keys(sandbox_314));
  let sandboxVals_316 = sandboxKeys_315.map(k_326 => sandbox_314[k_326]).toArray();
  let parsed_317 = reducer(new ParseReducer, new Term("Module", {directives: List(), items: List.of(new Term("ExpressionStatement", {expression: new Term("FunctionExpression", {isGenerator: false, name: null, params: new Term("FormalParameters", {items: sandboxKeys_315.map(param_327 => {
    return new Term("BindingIdentifier", {name: Syntax.fromIdentifier(param_327)});
  }), rest: null}), body: new Term("FunctionBody", {directives: List.of(new Term("Directive", {rawValue: "use strict"})), statements: List.of(new Term("ReturnStatement", {expression: expr_311}))})})}))}));
  let gen_318 = codegen(parsed_317, new FormattedCodeGen);
  let result_319 = context_312.transform(gen_318);
  return geval_307(result_319.code).apply(undefined, sandboxVals_316);
}
const loadSyntax_309 = _.cond([[_.where({binding: isBindingIdentifier}), _.curry(({binding, init}, context_328, env_329) => {
  let termExpander_330 = new TermExpander(context_328);
  let initValue_331 = loadForCompiletime_308(termExpander_330.expand(init), context_328);
  env_329.set(binding.name.resolve(), new CompiletimeTransform(initValue_331));
})], [_.T, __332 => assert(false, "not implemented yet")]]);
export default loadSyntax_309;
