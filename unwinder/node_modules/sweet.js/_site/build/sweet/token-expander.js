import {List} from "immutable";
import {enforestExpr, Enforester} from "./enforester";
import TermExpander from "./term-expander.js";
import BindingMap from "./binding-map.js";
import Env from "./env";
import Reader from "./shift-reader";
import  * as _ from "ramda";
import Term, {isEOF, isBindingIdentifier, isBindingPropertyProperty, isBindingPropertyIdentifier, isObjectBinding, isArrayBinding, isFunctionDeclaration, isFunctionExpression, isFunctionTerm, isFunctionWithName, isSyntaxDeclaration, isSyntaxrecDeclaration, isVariableDeclaration, isVariableDeclarationStatement, isImport, isExport} from "./terms";
import {Maybe} from "ramda-fantasy";
import {gensym} from "./symbol";
import {VarBindingTransform, CompiletimeTransform} from "./transforms";
import {expect, assert} from "./errors";
import loadSyntax from "./load-syntax";
import {Scope, freshScope} from "./scope";
const Just_875 = Maybe.Just;
const Nothing_876 = Maybe.Nothing;
const registerSyntax_877 = (stx_882, context_883) => {
  let newBinding_884 = gensym(stx_882.val());
  context_883.env.set(newBinding_884.toString(), new VarBindingTransform(stx_882));
  context_883.bindings.add(stx_882, {binding: newBinding_884, phase: 0, skipDup: true});
};
let registerBindings_878 = _.cond([[isBindingIdentifier, ({name}, context_885) => {
  registerSyntax_877(name, context_885);
}], [isBindingPropertyIdentifier, ({binding}, context_886) => {
  registerBindings_878(binding, context_886);
}], [isBindingPropertyProperty, ({binding}, context_887) => {
  registerBindings_878(binding, context_887);
}], [isArrayBinding, ({elements, restElement}, context_888) => {
  if (restElement != null) {
    registerBindings_878(restElement, context_888);
  }
  elements.forEach(el_889 => {
    if (el_889 != null) {
      registerBindings_878(el_889, context_888);
    }
  });
}], [isObjectBinding, ({properties}, context_890) => {}], [_.T, binding_891 => assert(false, "not implemented yet for: " + binding_891.type)]]);
let removeScope_879 = _.cond([[isBindingIdentifier, ({name}, scope_892) => new Term("BindingIdentifier", {name: name.removeScope(scope_892)})], [isArrayBinding, ({elements, restElement}, scope_893) => {
  return new Term("ArrayBinding", {elements: elements.map(el_894 => el_894 == null ? null : removeScope_879(el_894, scope_893)), restElement: restElement == null ? null : removeScope_879(restElement, scope_893)});
}], [isBindingPropertyIdentifier, ({binding, init}, scope_895) => new Term("BindingPropertyIdentifier", {binding: removeScope_879(binding, scope_895), init: init})], [isBindingPropertyProperty, ({binding, name}, scope_896) => new Term("BindingPropertyProperty", {binding: removeScope_879(binding, scope_896), name: name})], [isObjectBinding, ({properties}, scope_897) => new Term("ObjectBinding", {properties: properties.map(prop_898 => removeScope_879(prop_898, scope_897))})], [_.T, binding_899 => assert(false, "not implemented yet for: " + binding_899.type)]]);
function findNameInExports_880(name_900, exp_901) {
  let foundNames_902 = exp_901.reduce((acc_903, e_904) => {
    if (e_904.declaration) {
      return acc_903.concat(e_904.declaration.declarators.reduce((acc_905, decl_906) => {
        if (decl_906.binding.name.val() === name_900.val()) {
          return acc_905.concat(decl_906.binding.name);
        }
        return acc_905;
      }, List()));
    }
    return acc_903;
  }, List());
  assert(foundNames_902.size <= 1, "expecting no more than 1 matching name in exports");
  return foundNames_902.get(0);
}
function bindImports_881(impTerm_907, exModule_908, context_909) {
  let names_910 = [];
  impTerm_907.namedImports.forEach(specifier_911 => {
    let name_912 = specifier_911.binding.name;
    let exportName_913 = findNameInExports_880(name_912, exModule_908.exportEntries);
    if (exportName_913 != null) {
      let newBinding = gensym(name_912.val());
      context_909.bindings.addForward(name_912, exportName_913, newBinding);
      if (context_909.store.has(exportName_913.resolve())) {
        names_910.push(name_912);
      }
    }
  });
  return List(names_910);
}
export default class TokenExpander {
  constructor(context_914) {
    this.context = context_914;
  }
  expand(stxl_915) {
    let result_916 = List();
    if (stxl_915.size === 0) {
      return result_916;
    }
    let prev_917 = List();
    let enf_918 = new Enforester(stxl_915, prev_917, this.context);
    let self_919 = this;
    while (!enf_918.done) {
      let term = _.pipe(_.bind(enf_918.enforest, enf_918), _.cond([[isVariableDeclarationStatement, term_920 => {
        term_920.declaration.declarators = term_920.declaration.declarators.map(decl_921 => {
          return new Term("VariableDeclarator", {binding: removeScope_879(decl_921.binding, self_919.context.useScope), init: decl_921.init});
        });
        if (isSyntaxDeclaration(term_920.declaration)) {
          let scope = freshScope("nonrec");
          term_920.declaration.declarators.forEach(decl_922 => {
            let name_923 = decl_922.binding.name;
            let nameAdded_924 = name_923.addScope(scope);
            let nameRemoved_925 = name_923.removeScope(self_919.context.currentScope[self_919.context.currentScope.length - 1]);
            let newBinding_926 = gensym(name_923.val());
            self_919.context.bindings.addForward(nameAdded_924, nameRemoved_925, newBinding_926);
            decl_922.init = decl_922.init.addScope(scope, self_919.context.bindings);
          });
        }
        if (isSyntaxDeclaration(term_920.declaration) || isSyntaxrecDeclaration(term_920.declaration)) {
          term_920.declaration.declarators.forEach(decl_927 => {
            registerBindings_878(decl_927.binding, self_919.context);
            loadSyntax(decl_927, self_919.context, self_919.context.env);
          });
          return Nothing_876();
        } else {
          term_920.declaration.declarators.forEach(decl_928 => registerBindings_878(decl_928.binding, self_919.context));
        }
        return Just_875(term_920);
      }], [isFunctionWithName, term_929 => {
        term_929.name = removeScope_879(term_929.name, self_919.context.useScope);
        registerBindings_878(term_929.name, self_919.context);
        return Just_875(term_929);
      }], [isImport, term_930 => {
        let mod_931 = self_919.context.modules.load(term_930.moduleSpecifier.val(), self_919.context);
        if (term_930.forSyntax) {
          console.log("import for syntax is not implemented yet");
        } else {
          mod_931.visit(self_919.context);
        }
        let boundNames_932 = bindImports_881(term_930, mod_931, self_919.context);
        if (boundNames_932.size === 0) {
          return Just_875(term_930);
        }
        return Nothing_876();
      }], [isEOF, Nothing_876], [_.T, Just_875]]), Maybe.maybe(List(), _.identity))();
      result_916 = result_916.concat(term);
    }
    return result_916;
  }
}
