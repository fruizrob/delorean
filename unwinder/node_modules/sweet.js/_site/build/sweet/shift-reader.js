import Tokenizer from "shift-parser/dist/tokenizer";
import {TokenClass, TokenType} from "shift-parser/dist/tokenizer";
import {List} from "immutable";
import Syntax from "./syntax";
import  * as R from "ramda";
import {Maybe} from "ramda-fantasy";
import {assert} from "./errors";
const Just_486 = Maybe.Just;
const Nothing_487 = Maybe.Nothing;
import Term from "./terms";
const LSYNTAX_488 = {name: "left-syntax"};
const RSYNTAX_489 = {name: "right-syntax"};
const literalKeywords_490 = ["this", "null", "true", "false"];
const isLeftBracket_491 = R.whereEq({type: TokenType.LBRACK});
const isLeftBrace_492 = R.whereEq({type: TokenType.LBRACE});
const isLeftParen_493 = R.whereEq({type: TokenType.LPAREN});
const isRightBracket_494 = R.whereEq({type: TokenType.RBRACK});
const isRightBrace_495 = R.whereEq({type: TokenType.RBRACE});
const isRightParen_496 = R.whereEq({type: TokenType.RPAREN});
const isEOS_497 = R.whereEq({type: TokenType.EOS});
const isHash_498 = R.whereEq({type: TokenType.IDENTIFIER, value: "#"});
const isLeftSyntax_499 = R.whereEq({type: LSYNTAX_488});
const isRightSyntax_500 = R.whereEq({type: RSYNTAX_489});
const isLeftDelimiter_501 = R.anyPass([isLeftBracket_491, isLeftBrace_492, isLeftParen_493, isLeftSyntax_499]);
const isRightDelimiter_502 = R.anyPass([isRightBracket_494, isRightBrace_495, isRightParen_496, isRightSyntax_500]);
const isMatchingDelimiters_503 = R.cond([[isLeftBracket_491, (__544, b_545) => isRightBracket_494(b_545)], [isLeftBrace_492, (__546, b_547) => isRightBrace_495(b_547)], [isLeftParen_493, (__548, b_549) => isRightParen_496(b_549)], [isLeftSyntax_499, (__550, b_551) => isRightSyntax_500(b_551)], [R.T, R.F]]);
const assignOps_504 = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","];
const binaryOps_505 = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"];
const unaryOps_506 = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"];
const isEmpty_507 = R.whereEq({size: 0});
const isPunctuator_508 = s_552 => s_552.isPunctuator();
const isKeyword_509 = s_553 => s_553.isKeyword();
const isDelimiter_510 = s_554 => s_554.isDelimiter();
const isParens_511 = s_555 => s_555.isParens();
const isBraces_512 = s_556 => s_556.isBraces();
const isBrackets_513 = s_557 => s_557.isBrackets();
const isIdentifier_514 = s_558 => s_558.isIdentifier();
const val_515 = s_559 => s_559.val();
const isVal_516 = R.curry((v_560, s_561) => s_561.val() === v_560);
const isDot_517 = R.allPass([isPunctuator_508, isVal_516(".")]);
const isColon_518 = R.allPass([isPunctuator_508, isVal_516(":")]);
const isFunctionKeyword_519 = R.allPass([isKeyword_509, isVal_516("function")]);
const isOperator_520 = s_562 => (s_562.isPunctuator() || s_562.isKeyword()) && R.any(R.equals(s_562.val()), assignOps_504.concat(binaryOps_505).concat(unaryOps_506));
const isNonLiteralKeyword_521 = R.allPass([isKeyword_509, s_563 => R.none(R.equals(s_563.val()), literalKeywords_490)]);
const isKeywordExprPrefix_522 = R.allPass([isKeyword_509, s_564 => R.any(R.equals(s_564.val()), ["instanceof", "typeof", "delete", "void", "yield", "throw", "new", "case"])]);
let last_523 = p_565 => p_565.last();
let safeLast_524 = R.pipe(R.cond([[isEmpty_507, R.always(Nothing_487())], [R.T, R.compose(Maybe.of, last_523)]]));
let stuffTrue_525 = R.curry((p_566, b_567) => b_567 ? Just_486(p_566) : Nothing_487());
let stuffFalse_526 = R.curry((p_568, b_569) => !b_569 ? Just_486(p_568) : Nothing_487());
let isTopColon_527 = R.pipe(safeLast_524, R.map(isColon_518), Maybe.maybe(false, R.identity));
let isTopPunctuator_528 = R.pipe(safeLast_524, R.map(isPunctuator_508), Maybe.maybe(false, R.identity));
let isExprReturn_529 = R.curry((l_570, p_571) => {
  let retKwd_572 = safeLast_524(p_571);
  let maybeDot_573 = pop_540(p_571).chain(safeLast_524);
  if (maybeDot_573.map(isDot_517).getOrElse(false)) {
    return true;
  }
  return retKwd_572.map(s_574 => {
    return s_574.isKeyword() && s_574.val() === "return" && s_574.lineNumber() === l_570;
  }).getOrElse(false);
});
const isTopOperator_530 = R.pipe(safeLast_524, R.map(isOperator_520), Maybe.maybe(false, R.identity));
const isTopKeywordExprPrefix_531 = R.pipe(safeLast_524, R.map(isKeywordExprPrefix_522), Maybe.maybe(false, R.identity));
let isExprPrefix_532 = R.curry((l_575, b_576) => R.cond([[isEmpty_507, R.always(b_576)], [isTopColon_527, R.always(b_576)], [isTopKeywordExprPrefix_531, R.T], [isTopOperator_530, R.T], [isTopPunctuator_528, R.always(b_576)], [isExprReturn_529(l_575), R.T], [R.T, R.F]]));
let curly_533 = p_577 => safeLast_524(p_577).map(isBraces_512).chain(stuffTrue_525(p_577));
let paren_534 = p_578 => safeLast_524(p_578).map(isParens_511).chain(stuffTrue_525(p_578));
let func_535 = p_579 => safeLast_524(p_579).map(isFunctionKeyword_519).chain(stuffTrue_525(p_579));
let ident_536 = p_580 => safeLast_524(p_580).map(isIdentifier_514).chain(stuffTrue_525(p_580));
let nonLiteralKeyword_537 = p_581 => safeLast_524(p_581).map(isNonLiteralKeyword_521).chain(stuffTrue_525(p_581));
let opt_538 = R.curry((a_582, b_583, p_584) => {
  let result_585 = R.pipeK(a_582, b_583)(Maybe.of(p_584));
  return Maybe.isJust(result_585) ? result_585 : Maybe.of(p_584);
});
let notDot_539 = R.ifElse(R.whereEq({size: 0}), Just_486, p_586 => safeLast_524(p_586).map(s_587 => !(s_587.isPunctuator() && s_587.val() === ".")).chain(stuffTrue_525(p_586)));
let pop_540 = R.compose(Just_486, p_588 => p_588.pop());
const functionPrefix_541 = R.pipeK(curly_533, pop_540, paren_534, pop_540, opt_538(ident_536, pop_540), func_535);
const isRegexPrefix_542 = b_589 => R.anyPass([isEmpty_507, isTopPunctuator_528, R.pipe(Maybe.of, R.pipeK(nonLiteralKeyword_537, pop_540, notDot_539), Maybe.isJust), R.pipe(Maybe.of, R.pipeK(paren_534, pop_540, nonLiteralKeyword_537, pop_540, notDot_539), Maybe.isJust), R.pipe(Maybe.of, functionPrefix_541, R.chain(p_590 => {
  return safeLast_524(p_590).map(s_591 => s_591.lineNumber()).chain(fnLine_592 => {
    return pop_540(p_590).map(isExprPrefix_532(fnLine_592, b_589));
  }).chain(stuffFalse_526(p_590));
}), Maybe.isJust), p_593 => {
  let isCurly_594 = Maybe.isJust(safeLast_524(p_593).map(isBraces_512));
  let alreadyCheckedFunction_595 = R.pipe(Maybe.of, functionPrefix_541, Maybe.isJust)(p_593);
  if (alreadyCheckedFunction_595) {
    return false;
  }
  return R.pipe(Maybe.of, R.chain(curly_533), R.chain(p_596 => {
    return safeLast_524(p_596).map(s_597 => s_597.lineNumber()).chain(curlyLine_598 => {
      return pop_540(p_596).map(isExprPrefix_532(curlyLine_598, b_589));
    }).chain(stuffFalse_526(p_596));
  }), Maybe.isJust)(p_593);
}]);
function lastEl_543(l_599) {
  return l_599[l_599.length - 1];
}
export default class Reader extends Tokenizer {
  constructor(strings_600, context_601, replacements_602) {
    super(Array.isArray(strings_600) ? strings_600.join("") : strings_600);
    this.delimStack = new Map;
    this.insideSyntaxTemplate = [false];
    this.context = context_601;
    if (Array.isArray(strings_600)) {
      let totalIndex = 0;
      this.replacementIndex = R.reduce((acc_603, strRep_604) => {
        acc_603.push({index: totalIndex + strRep_604[0].length, replacement: strRep_604[1]});
        totalIndex += strRep_604[0].length;
        return acc_603;
      }, [], R.zip(strings_600, replacements_602));
    }
  }
  read(stack_605 = [], b_606 = false, singleDelimiter_607 = false) {
    let prefix_608 = List();
    while (true) {
      let tok = this.advance(prefix_608, b_606);
      if (tok instanceof Syntax || tok instanceof Term) {
        stack_605.push(tok);
        continue;
      }
      if (Array.isArray(tok)) {
        Array.prototype.push.apply(stack_605, tok);
        continue;
      }
      if (List.isList(tok)) {
        Array.prototype.push.apply(stack_605, tok.toArray());
        continue;
      }
      if (isEOS_497(tok)) {
        if (stack_605[0] && isLeftDelimiter_501(stack_605[0].token)) {
          throw this.createUnexpected(tok);
        }
        break;
      }
      if (isLeftDelimiter_501(tok)) {
        if (isLeftSyntax_499(tok)) {
          this.insideSyntaxTemplate.push(true);
        }
        let line = tok.slice.startLocation.line;
        let innerB = isLeftBrace_492(tok) ? isExprPrefix_532(line, b_606)(prefix_608) : true;
        let inner = this.read([new Syntax(tok)], innerB, false);
        let stx = new Syntax(inner, this.context);
        prefix_608 = prefix_608.concat(stx);
        stack_605.push(stx);
        if (singleDelimiter_607) {
          break;
        }
      } else if (isRightDelimiter_502(tok)) {
        if (stack_605[0] && !isMatchingDelimiters_503(stack_605[0].token, tok)) {
          throw this.createUnexpected(tok);
        }
        let stx = new Syntax(tok, this.context);
        stack_605.push(stx);
        if (lastEl_543(this.insideSyntaxTemplate) && isRightSyntax_500(tok)) {
          this.insideSyntaxTemplate.pop();
        }
        break;
      } else {
        let stx = new Syntax(tok, this.context);
        prefix_608 = prefix_608.concat(stx);
        stack_605.push(stx);
      }
    }
    return List(stack_605);
  }
  advance(prefix_609, b_610) {
    let startLocation_611 = this.getLocation();
    this.lastIndex = this.index;
    this.lastLine = this.line;
    this.lastLineStart = this.lineStart;
    this.skipComment();
    this.startIndex = this.index;
    this.startLine = this.line;
    this.startLineStart = this.lineStart;
    if (this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
      let rep = this.replacementIndex[0].replacement;
      this.replacementIndex.shift();
      return rep;
    }
    let charCode_612 = this.source.charCodeAt(this.index);
    if (charCode_612 === 96) {
      let element, items = [];
      let startLocation_611 = this.getLocation();
      let start = this.index;
      this.index++;
      if (lastEl_543(this.insideSyntaxTemplate)) {
        let slice = this.getSlice(start, startLocation_611);
        return {type: RSYNTAX_489, value: "`", slice: slice};
      }
      do {
        element = this.scanTemplateElement();
        items.push(element);
        if (element.interp) {
          element = this.read([], false, true);
          assert(element.size === 1, "should only have read a single delimiter inside a template");
          items.push(element.get(0));
        }
      } while (!element.tail);
      return {type: TokenType.TEMPLATE, items: List(items)};
    } else if (charCode_612 === 35) {
      let startLocation_611 = this.getLocation();
      let start = this.index;
      let slice = this.getSlice(start, startLocation_611);
      this.index++;
      if (this.source.charCodeAt(this.index) === 96) {
        this.index++;
        return {type: LSYNTAX_488, value: "#`", slice: slice};
      }
      return {type: TokenType.IDENTIFIER, value: "#", slice: slice};
    }
    let lookahead_613 = super.advance();
    if (lookahead_613.type === TokenType.DIV && isRegexPrefix_542(b_610)(prefix_609)) {
      return super.scanRegExp("/");
    }
    return lookahead_613;
  }
  scanTemplateElement() {
    let startLocation_614 = this.getLocation();
    let start_615 = this.index;
    while (this.index < this.source.length) {
      let ch = this.source.charCodeAt(this.index);
      switch (ch) {
        case 96:
          let slice = this.getSlice(start_615, startLocation_614);
          this.index++;
          return {type: TokenType.TEMPLATE, tail: true, interp: false, slice: slice};
        case 36:
          if (this.source.charCodeAt(this.index + 1) === 123) {
            let slice = this.getSlice(start_615, startLocation_614);
            this.index += 1;
            return {type: TokenType.TEMPLATE, tail: false, interp: true, slice: slice};
          }
          this.index++;
          break;
        case 92:
          {
            let octal = this.scanStringEscape("", null)[1];
            if (octal != null) {
              throw this.createILLEGAL();
            }
            break;
          }
        default:
          this.index++;
      }
    }
    throw this.createILLEGAL();
  }
}
