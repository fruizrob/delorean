import MapSyntaxReducer from "./map-syntax-reducer";
import reducer from "shift-reducer";
import {List} from "immutable";
import {Enforester} from "./enforester";
import Syntax from "./syntax";
import  * as _ from "ramda";
import {Maybe} from "ramda-fantasy";
const Just_333 = Maybe.Just;
const Nothing_334 = Maybe.Nothing;
const symWrap_335 = Symbol("wrapper");
const isKind_336 = _.curry((kind_350, t_351, v_352) => {
  if (t_351 instanceof Syntax) {
    return t_351[kind_350]() && (v_352 == null || t_351.val() == v_352);
  }
});
const isKeyword_337 = isKind_336("isKeyword");
const isIdentifier_338 = isKind_336("isIdentifier");
const isNumericLiteral_339 = isKind_336("isNumericLiteral");
const isStringLiteral_340 = isKind_336("isStringLiteral");
const isNullLiteral_341 = isKind_336("isNullLiteral");
const isPunctuator_342 = isKind_336("isPunctuator");
const isRegularExpression_343 = isKind_336("isRegularExpression");
const isBraces_344 = isKind_336("isBraces");
const isBrackets_345 = isKind_336("isBrackets");
const isParens_346 = isKind_336("isParens");
const isDelimiter_347 = isKind_336("isDelimiter");
const getLineNumber_348 = t_353 => {
  if (t_353 instanceof Syntax) {
    return t_353.lineNumber();
  }
  throw new Error("Line numbers on terms not implemented yet");
};
const getVal_349 = t_354 => {
  if (isDelimiter_347(t_354, null)) {
    return null;
  }
  if (t_354 instanceof Syntax) {
    return t_354.val();
  }
  return null;
};
export class SyntaxOrTermWrapper {
  constructor(s_355, context_356 = {}) {
    this[symWrap_335] = s_355;
    this.context = context_356;
  }
  isKeyword(value_357) {
    return isKeyword_337(this[symWrap_335], value_357);
  }
  isIdentifier(value_358) {
    return isIdentifier_338(this[symWrap_335], value_358);
  }
  isNumericLiteral(value_359) {
    return isNumericLiteral_339(this[symWrap_335], value_359);
  }
  isStringLiteral(value_360) {
    return isStringLiteral_340(this[symWrap_335], value_360);
  }
  isNullLiteral(value_361) {
    return isNullLiteral_341(this[symWrap_335], value_361);
  }
  isPunctuator(value_362) {
    return isPunctuator_342(this[symWrap_335], value_362);
  }
  isRegularExpression(value_363) {
    return isRegularExpression_343(this[symWrap_335], value_363);
  }
  isBraces(value_364) {
    return isBraces_344(this[symWrap_335], value_364);
  }
  isBrackets(value_365) {
    return isBrackets_345(this[symWrap_335], value_365);
  }
  isParens(value_366) {
    return isParens_346(this[symWrap_335], value_366);
  }
  isDelimiter(value_367) {
    return isDelimiter_347(this[symWrap_335], value_367);
  }
  lineNumber() {
    return getLineNumber_348(this[symWrap_335]);
  }
  val() {
    return getVal_349(this[symWrap_335]);
  }
  inner() {
    let stx_368 = this[symWrap_335];
    if (!isDelimiter_347(stx_368, null)) {
      throw new Error("Can only get inner syntax on a delimiter");
    }
    let enf_369 = new Enforester(stx_368.inner(), List(), this.context);
    return new MacroContext(enf_369, "inner", this.context);
  }
}
export function unwrap(x_370) {
  if (x_370 instanceof SyntaxOrTermWrapper) {
    return x_370[symWrap_335];
  }
  return x_370;
}
export default class MacroContext {
  constructor(enf_371, name_372, context_373, useScope_374, introducedScope_375) {
    this._enf = enf_371;
    this.name = name_372;
    this.context = context_373;
    if (useScope_374 && introducedScope_375) {
      this.noScopes = false;
      this.useScope = useScope_374;
      this.introducedScope = introducedScope_375;
    } else {
      this.noScopes = true;
    }
    this[Symbol.iterator] = () => this;
  }
  next(type_376 = "Syntax") {
    if (this._enf.rest.size === 0) {
      return {done: true, value: null};
    }
    let value_377;
    switch (type_376) {
      case "AssignmentExpression":
      case "expr":
        value_377 = this._enf.enforestExpressionLoop();
        break;
      case "Expression":
        value_377 = this._enf.enforestExpression();
        break;
      case "Syntax":
        value_377 = this._enf.advance();
        if (!this.noScopes) {
          value_377 = value_377.addScope(this.useScope).addScope(this.introducedScope, this.context.bindings, {flip: true});
        }
        break;
      default:
        throw new Error("Unknown term type: " + type_376);
    }
    return {done: false, value: new SyntaxOrTermWrapper(value_377, this.context)};
  }
}
