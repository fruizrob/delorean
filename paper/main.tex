\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[spanish]{babel}
\usepackage{url}
\urlstyle{rm}

\input{notes}
\input{listing}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{DeloreanJS: Un Debugger en el Tiempo para JavaScript}

\author{\IEEEauthorblockN{Paul Leger}
\IEEEauthorblockA{\textit{Escuela de Ingenier\'ia} \\
\textit{Universidad Cat\'olica del Norte}\\
Coquimbo, Chile \\
pleger@ucn.cl}
\and
\IEEEauthorblockN{AAAA BBBB}
\IEEEauthorblockA{\textit{Escuela de Ingenier\'ia} \\
\textit{Universidad Cat\'olica del Norte}\\
Coquimbo, Chile \\
aaaa.bbbb@alumnos.ucn.cl}
\and
\IEEEauthorblockN{XXXX YYYY}
\IEEEauthorblockA{\textit{Escuela de Ingenier\'ia} \\
\textit{Universidad Cat\'olica del Norte}\\
Coquimbo, Chile \\
xxxx.yyyy@alumnos.ucn.cl}
}

\maketitle

\begin{abstract}
Aplicaciones Web, usando \javascript, son desarrolladas cada vez con mayor frecuencia. Como en la mayor\'ia de los entornos de desarrollos, una aplicaci\'on Web puede adquirir defectos de software (conocido como {\em bugs}), cuyos s\'intomas se aprecian durante este desarrollo e incluso, siendo peor, en producci\'on. Para ello, el uso de debuggers son sumamente \'utiles para detectar estos bugs. Lamentablemente, los actuales debuggers solamente avanzan hacia adelante en la ejecuci\'on para detectar un bug y no permiten retornar hacia un punto anterior en la ejecuci\'on para tomar acciones asociadas al bug detectado. Por ejemplo, probar si el mismo bug podr\'ia gatillarse con otro valor de una variable. Usando el concepto de continuaciones, este art\'iculo presenta un debugger, llamado \deloreanjs,  para \javascript que permite devolverse en el tiempo con el fin que un programador pueda volver a verificar y probar el contexto alrededor de un bug. Este debugger ha sido implementado como una extensi\'on para Google Chrome con el fin que la comunidad de desarrolladores pueda usarlo.         
\end{abstract}

\begin{IEEEkeywords}
\deloreanjs, \javascript, Debugger, Web application, Continuations
\end{IEEEkeywords}

\section{Introducci\'on}
\label{sec:intro}

Para construir aplicaciones Web, uno de los lenguajes m\'as usados es \javascript, cuya presencia en el entorno de la Web es de alrededor del 95\%~\cite{jsuses}. La industria del software se mueve fuertemente hacia el desarrollo de este tipo de aplicaciones, siendo testigo un gran n\'umero de migraciones de aplicaciones {\em standalone} a la Web; los ejemplos van desde convertir un documento Word a un formato PDF~\cite{smallpdf} hasta un sistema ERP ({\em Enterprise Resource Planning})~\cite{erpOrcale}. Por ello, cada vez estas aplicaciones se han vuelto m\'as complejas y con mayor riesgo de introducir defectos de software (\aka {\em bugs}). 

Detectar y reparar bugs representa una de las tareas m\'as costosa en el proceso de desarrollo de software, y las aplicaciones Web no son la excepci\'on. Para aliviar el proceso de tratamiento de bugs, un conjunto de debuggers se han propuestos, desde el que incluye un navegador en su distribuci\'on (\eg Mozilla Firefox developer tools) hasta  debuggers omniscientes que pueden recorrer a trav\'es de la traza de ejecuci\'on para encontrar el origen de un bug~\cite{azar:2016,barrAl:fse2016}. Considerando estos \'ultimos debuggers, ellos son {\em post-morter}, y es decir, solo permiten mostrar la ocurrencia de un bug sin entregar la posibilidad de retroceder {\em en el tiempo} para que un programador pueda repararlo mientras se ejecuta o manipular el estado de las variables alrededor del bug para mejorar la comprensi\'on de su causa.       

Este art\'iculo cient\'ifico presenta \deloreanjs, un debugger que permite al desarrollador en una aplicaci\'on Web escrita en \javascript fijar {\em timepoints} (en cambio de {\em breakpoints}) para entregar la posibilidad retornar en el tiempo a esos puntos y modificar valores de variables para continuar la ejecuci\'on del programa. Este novedoso enfoque de \deloreanjs permite:    

\begin{enumerate}
	
	\item Modificar los valores de las variables asociado a un bug encontrado para mejorar la comprensi\'on de \'este. Lo anterior puede ahorrar un gran n\'umero de ejecuciones usando un contexto similar para descubrir la verdadera raz\'on del bug.

	\smallskip

	\item Probar escenarios hipot\'eticos de la ejecuci\'on de una aplicaci\'on Web usando un timepoint de \deloreanjs. Esto permite explorar diversas evoluciones de la ejecuaci\'on de la aplicaci\'on cambiando valores de algunas de sus variables.
   
   \smallskip
	 
	\item Mantener una aplicaci\'on Web funcionando usando los timepoints para potencialmente reparar un bug durante la ejecuci\'on. Lo anterior significa que no es siempre necesario detener la ejecuci\'on de la aplicaci\'on con el fin de realizar un anal\'isis post-morter, implicando perder el contexto de ejecuci\'on asociado al bug.  

\end{enumerate}


Para construir \deloreanjs, utilizamos la abstracci\'on {\em continuaci\'on}~\cite{fw84} de los lenguajes de programaci\'on funcional como Scheme~\cite{scheme48}. Una continuaci\'on permite al programador capturar y guardar, como valor del lenguaje, un momento en la ejecuci\'on ({\em program counter} y {\em stack}) de una aplicaci\'on. Extendiendo esta abstracci\'on para lenguajes no funcionales como \javascript, nosotros habilitamos a \deloreanjs para que ofrezca la posibilidad a un programador de expresar la insercci\'on de timepoints a una aplicaci\'on Web,  y as\'i poder volver esos momentos de ejecuci\'on y modificarlos cuando es requerido.   


El art\'iculo est\'a organizado como sigue. La secci\'on~\ref{sec:tour} presenta diferentes ejemplos de aplicaci\'on de \deloreanjs, donde se puede apreciar la interfaz gr\'afica de nuestra propuesta. Luego, se presenta \deloreanjs, detallando c\'omo se usa el concepto de continuaciones. En la secci\'on~\ref{sec:rw} se discuten herramientas similares. Finalmente, secci\'on~\ref{sec:conc} concluye y describe lineamientos sobre el trabajo futuro de nuestra propuesta.      

\smallskip

{\bf {\em Disponibilidad.}} El c\'odigo fuente de la implementaci\'on de \deloreanjs se encuentra en {\tt \url{http://github.com/fruizrob/delorean}} y una prueba de concepto de su aplicaci\'on se puede obtener, como extensi\'on de Google Chrome, en {\tt \url{http://xxx.com}}. 



\section{Un Tour por \deloreanjs}
\label{sec:tour}

\pl{Cada ejemplo debe tener el nombre de lo que hace}

\subsection{Ejemplo 1}
\label{sec:tour1}

\pl{Explicar con imagenes el ejemplo 1}

\subsection{Ejemplo 2}
\label{sec:tour2}

\pl{Explicar con imagenes el ejemplo 2}

\subsection{Ejemplo 3}
\label{sec:tour3}

\pl{Explicar con imagenes el ejemplo 3}

\bigskip

\section{\deloreanjs}
\label{sec:deloreanjs}

Dado que nuestra propuesta muestra un enfoque relativamente diferente a los existentes debuggers, esta secci\'on describe c\'omo funciona \deloreanjs y los conceptos necesarios para construirla.   

Figura~\ref{fig:timeline} muestra las multiples trazas de ejecuci\'on, llamadas por {\em timelines}, de una aplicaci\'on Web producidas por los timepoints. Cuando un programador define un timepoint, durante la ejecuci\'on de la aplicaci\'on se puede volver a ese timepoint y as\'i crear una timeline de la ejecuci\'on de la aplicaci\'on.   

\begin{figure*}[t]
\begin{center}
\includegraphics[width=.6\linewidth]{fig-timeline}
\caption{Multiples trazas de ejecuciones de a trav\'es de timepoints de \deloreanjs.}
\label{fig:timeline}
\end{center}
\end{figure*}




\subsection{Continuaciones}
\label{sec:continuaciones}


\begin{figure*}[t]
\begin{center}
\includegraphics[width=.7\linewidth]{fig-kont}
\caption{The flowchart of Listing~\ref{lst:rhino_1}, which uses the continuation
  \co{kont}. The invocation of \co{kont} uses a \co{parameter} to replace the
  return value of the anonymous function inside of \co{add} (\ie ``\co{return 1}'').}
\label{fig:kont}
\end{center}
\end{figure*}


This section briefly introduces \callcc and then explains how \synccc uses
them. Programming languages like Scheme provide continuations~\cite{fw84}, which
capture and store the current program control state as a first-class value. If
this value is a function, it can be called and the current continuation will be
replaced with the stored continuation. \unwinder~\cite{unwinder:2018} is a
\javascript library that captures the current continuation with a built-in
function, named \co{callCC}. We illustrate \callcc in \unwinder through a piece
of code that captures the execution of a function adding two numbers
(Listing~\ref{lst:rhino_1}): 

%\break

\begin{lstlisting}[linewidth=\columnwidth,numbers=left,caption=Use of continuations in the \unwinder library., label=lst:rhino_1]
var kont;

function add(x,y) {
  return x + (function() {
                kont = callCC(cont => cont);
                return typeof(kont) == "number"? kont:y;})();
}

show(add(5,1));                           //show 6
if (typeof(kont) == "function") kont(20); //show 25
\end{lstlisting}

Figure~\ref{fig:kont} shows a flowchart of the piece of code above. In Line~5,
the piece of code captures and stores the continuation in \co{kont} before
adding \co{y}. This capture takes place in Line~9 when \co{add} is called.  The
result of \co{add} is passed to \co{show}, and then the number \co{6} is
displayed.  Line~10 executes the continuation bound to \co{kont} with \co{20} as
parameter, which replaces the return of the anonymous function of Line~6 (\ie
\co{return 1} $\rightarrow$ \co{return 20}). As a result, \co{25} is displayed
(\co{25 = (x = 5) + (y = 20)}). Note that the {\em if expression} (Line~6) and
{\em if statement} (Line~10) are used to differentiate when a continuation is
created from being called. A continuation is a function (Line~9) if this
continuation has been created but not called, otherwise the continuation is
bound to the value passed by parameter when it is called (\ie~20 in this piece
of code).

If developers need to stop a handler execution, a continuation in the end of the
top-level script should be created. For example, Listing~\ref{lst:rhino_2}:

\begin{lstlisting}[caption=Stopping a \javascript script with continuations., label=lst:rhino_2]
function showMessageHandler() {
  show("This message will be shown");
  stop();
  show("This message will never be shown");
}

var stop = callCC(cont => cont);
\end{lstlisting}

\synccc uses two continuations: the first one stops a handler execution just
after an asynchronous operation invocation, and the second one resumes the
handler execution when the asynchronous operation response is available.

\subsection{Capturando el heap}
\label{sec:heap}

\pl{Explicar su forma de capturar estados}

\subsection{Extensi\'on en el Navegador}

\pl{Explicar la aplicaci\'on en Google Chrome}

\bigskip

\section{Trabajo Relacionado}
\label{sec:rw}

Dado que \javascript es un lenguaje muy ampliamente usado, existe un inter\'es constante en crear avances en t\'erminos de investigaci\'on~\cite{vazquesAl:ist2018,legerAl:scp2013,legerAl:scp2015,zhengAl:www2011,chargueraudAl:www2018} y desarrollo~\cite{resig:jquery,angular,mckenzie:babel,rxjs}. En estos avances, varios tipos de propuestas de debuggers son posible encontrar en la literatura. Algunos de ellos~\cite{bartonOdvarko:www2011,jsbin,nodejsInspector} ofrecen un amplio conjunto de caracter\'isticas como modificar los valores de variables mientras la aplicaci\'on se est\'a ejecutando (ej. FireBug~\cite{bartonOdvarko:www2011}). Aunque, en lo mejor de nuestro conocimiento, no es encontrar debuggers que sigan un enfoque similar a \deloreanjs, existen algunos que consideran la historia de ejecuci\'on de una aplicaci\'on Web:       

\smallskip

\parhead{Debuggers omniscientes} Estos tipos de debuggers se encargan de almacenar cada evento que ocurre en la ejecuci\'on de un programa, creando un historial de la traza de ejecuci\'on. Estos debuggers han sido implementados en lenguajes como en \java~\cite{tod:oopsla2007} y     xDSMLs~\cite{bousseAl:SLE2015}. Con respecto a  \javascript, podemos encontrar PECCit~\cite{azar:2016} y JARDIS~\cite{barrAl:fse2016}, los cuales almacenan la traza de ejecuci\'on y ofrecen diferentes interfaces de usuario para navegar a trav\'es de esta traza. A diferencia de \deloreanjs, estos tipos de debuggers son {\em post-morter}, significando que no es posible volver a un punto en la historia de esta ejecuci\'on y continuarla con valores de variables potencialmente modificados. 

\smallskip

\parhead{Debuggers remotos} \javascript es generalmente\footnote{Aparte de la Web, \javascript actualmente es usado en varios entornos de desarrollos, por ejemplo, es usado en el lado del servidor en una aplicaci\'on Web~\cite{nodejs:2018} y en administradores de ventas de sistemas operativos basados en Linux~\cite{gjs}.} usado para construir aplicaciones Web\ que son usadas por usuarios con alg\'un dispositivo que pertenece a un muy variado y amplio catalogo, pues lo \'unico que se necesita es un navegador con acceso a internet. Por esta raz\'on, cualquier configuraci\'on del dispositivo puede producir un potencial bug que los desarrolladores no podr\'ian observar en un ambiente de desarrollo controlado. Para abordar esta dificultad, existen debuggers~\cite{sessionstack,raygun,trackjs} que supervisan remotamente las ejecuciones de los usuarios. Similarmente a los debuggers omniscientes, estos registran y env\'ian cada punto ejecuci\'on a un desarrollador por la red. Aunque estos debuggers permiten a los desarrolladores trazas de ejecuciones de diferentes usuarios en tiempo real, no ofrecen la posibilidad de retroceder en momentos de la ejecuci\'on a los usuarios.   

\section{Conclusiones}
\label{sec:conc}


No es un misterio que la industria del software se est\'e orientando a construir aplicaciones Web cada vez m\'as grandes y complejas, implicando que exista una mayor probabilidad que aparezcan bugs. Para construir estas aplicaciones, el lenguaje \javascript es ampliamente usado y una amplia cantidad de debuggers se encuentra disponible en la Web~\cite{bartonOdvarko:www2011,jsbin,nodejsInspector,sessionstack,raygun,trackjs,azar:2016,barrAl:fse2016}. Sin embargo, a diferencia de \deloreanjs, ninguno de estos debuggers considera el enfoque de {\em retroceder en el tiempo} a momento en la ejeucuci\'on una aplicaci\'on escrita en \javascript. Sin este enfoque, hay un conjunto de oportunidades que un programador pierde, por ejemplo, probar distintos valores de variables en un mismo contexto de ejecuci\'on con el objetivo de mejorar la comprensi\'on del bug o explorar escenarios hipot\'eticos de la evoluci\'on de la ejecuci\'on dado un mismo contexto inicial. Para alcanzar una adopci\'on por parte de la comunidad, \deloreanjs tiene a\'un algunos desaf\'ios:  
   
\smallskip

\parhead{Guardar el heap} A diferencia del stack que se guarda autom\'aticamente en una aplicaci\'on en ejecuci\'on, un programador debe ahora especificar qu\'e variables del heap se guardar\'an en los timepoints. Resolver este desaf\'io implica almacenar copias de las variables contenidas en el heap por cada timepoint.      

\smallskip

\parhead{Integrar a un existente debugger} Actualmente \deloreanjs ofrece el nuevo enfoque de retroceder en el tiempo de una ejecuci\'on. Integrar este enfoque con las caracter\'isticas de los existentes debuggers podr\'ia significativamente la adopci\'on de nuestra propuesta. Por ejemplo, debuggers omniscientes integrado con \deloreanjs permitir\'ia analizar multiple trazas de ejecuciones partiendo desde un timepoint.

\smallskip

Como limitaci\'on podemos mencionar que \deloreanjs realiza la promesa de retornar en el tiempo de una ejecuci\'on, la cual podr\'ia no cumplirse a totalidad si aplicaci\'on depende de los resultados de eventos externos (ej. servicio Web que entrega la hora actual). Sin embargo, esta limitaci\'on se encuentra tambi\'en presenta en los existentes debuggers.               

\bibliographystyle{IEEEtran}
\bibliography{djs}


\end{document}
